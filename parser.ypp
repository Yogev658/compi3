%{

#include "hw3_output.hpp"
#include "symbolTable.h"
#include "Element.h"

#include <iostream>
#include <stdlib.h>

using namespace output;
using namespace std;

extern int yylex();
extern int yylineno;

void yyerror (const char*);

SymbolTable table;

%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token AUTO
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING

%right NOT
%right IF
%right ASSIGN

%left AND
%left OR
%left LPAREN
%left RPAREN
%left RELOP_EQ
%left BINOP_MULT
%left BINOP_ADD

%nonassoc ELSE
%nonassoc RELOP_REL

%%

Program : Funcs {;};

Funcs : /* epsilon */ {;}
      | FuncDecl Funcs {;};

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE {table.pushFunctionScope($4->to<FormalsList>()); } Statements RBRACE {table.popFunctionScope();};

RetType : Type {$$ = new Type($1->to<Type>()->type);}
        | VOID {$# = new Type(TYPE_VOID); };

Formals : /* epsilon */ {$$ = nullptr;}
        | FormalsList {$$ = $1;};

FormalsList : FormalDecl {$$ = $1;}
            | FormalDecl COMMA FormalsList {
                pair<TypeName, string> newPair = (*($1->to<FormalsList>()->args))[0];
                $3->to<FormalsList>()->addToFormalList(newPair);
                $$ = $3;};

FormalDecl : Type ID {
    $$ = new FormalsList(new vector<pair<TypeName, string>>()); 
    const TypeName type = $1->to<Type>()->type;
    const string name = string($2->to<Identifier>()->name);
    pair<TypeName, string> newPair = make_pair(type, name);
    $$->to<FormalsList>()->addToFormalList(newPair);
    };

Statements : Statement {printProductionRule(12); }
           | Statements Statement {printProductionRule(13); };

Statement : LBRACE Statements RBRACE {printProductionRule(14); }
          | Type ID SC {$$ = new Statement($1->to<Type>()->type); }
          | Type ID ASSIGN Exp SC {$$ = new Statement($1->to<Type>()->type); }
          | AUTO ID ASSIGN Exp SC {$$ = new Statement($4->to<Exp>()->type); }
          | ID ASSIGN Exp SC {printProductionRule(18); }
          | Call SC {printProductionRule(19); }
          | RETURN SC {printProductionRule(20); }
          | RETURN Exp SC {printProductionRule(21); }
          | IF LPAREN Exp RPAREN Statement {printProductionRule(22); }
          | IF LPAREN Exp RPAREN Statement ELSE Statement {printProductionRule(23); }
          | WHILE LPAREN Exp RPAREN Statement {printProductionRule(24); }
          | BREAK SC {printProductionRule(25); }
          | CONTINUE SC {printProductionRule(26); };

Call : ID LPAREN ExpList RPAREN {$$ = new Call($1->to<Identifier>()->type); }
     | ID LPAREN RPAREN {$$ = new Call($1->to<Identifier>()->type); };

ExpList : Exp {printProductionRule(29); }
     | Exp COMMA ExpList {printProductionRule(30); };

Type : INT {$$ = new Type(TYPE_INT);}
    | BYTE {$$ = new Type(TYPE_BYTE); }
    | BOOL {$$ = new Type(TYPE_BOOL); };

Exp : LPAREN Exp RPAREN {printProductionRule(34); }
    | Exp BINOP_ADD Exp {printProductionRule(35); }
    | Exp BINOP_MULT Exp {printProductionRule(35); }
    | ID {printProductionRule(36); }
    | Call {printProductionRule(37); }
    | NUM {$$ = new Exp(TYPE_INT);}
    | NUM B {$$ = new Exp(TYPE_INT);}
    | STRING {$$ = new Exp(TYPE_STRING);}
    | TRUE {$$ = new Exp(TYPE_BOOL);}
    | FALSE  {$$ = new Exp(TYPE_BOOL);}
    | NOT Exp {$$ = new Exp($1->to<Exp>()->type);}
    | Exp AND Exp { /* assert they have the same type */ $$ = new Exp($1->to<Exp>()->type);}
    | Exp OR Exp  { /* assert they have the same type */ $$ = new Exp($1->to<Exp>()->type);}
    | Exp RELOP_EQ Exp  { /* assert they have the same type */ $$ = new Exp($1->to<Exp>()->type);}
    | Exp RELOP_REL Exp { /* assert they have the same type */ $$ = new Exp($1->to<Exp>()->type);}
    | LPAREN Type RPAREN Exp  { /* assert casting is legal */ $$ = new Exp($2->to<Exp>()->type);};

%%

int main() {
    table = SymbolTable();
    return yyparse();
}

void yyerror(const char*) {
    errorSyn(yylineno);
}